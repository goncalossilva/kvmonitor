<!DOCTYPE html>

<html>
  <head>
    <meta name="viewport" content="width=device-width" />
    <script>
      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      async function play() {
        let element = document.getElementById('stream');

        let mediaSource = new MediaSource();
        element.src = URL.createObjectURL(mediaSource);
        element.play();

        if (mediaSource.readyState != "open") {
          await new Promise(resolve => mediaSource.addEventListener('sourceopen', resolve));
        }

        let srcBuffer = mediaSource.addSourceBuffer('audio/webm; codecs="opus"');
        srcBuffer.mode = "sequence";

        let onUpdateEnd = () => {};
        srcBuffer.addEventListener("updateend", () => {
          onUpdateEnd();
        });

        let waitUpdate = async () => {
          while (srcBuffer.updating) {
            await new Promise(resolve => { onUpdateEnd = resolve; });
            onUpdateEnd = () => {};
          }
        };

        let lastLatency = 0;

        for (;;) {
          try {
            let resp = await fetch("/stream.webm");
            let reader = resp.body.getReader();

            for (;;) {
              let {done, value: bytes} = await reader.read();

              if (done) {
                console.log("stream ended???");
                break;
              }

              await waitUpdate();

              if (srcBuffer.buffered.length > 0) {
                let start = srcBuffer.buffered.start(0);
                let end = srcBuffer.buffered.end(srcBuffer.buffered.length - 1);

                // Don't fall too far behind in the local buffer.
                // However, in my tests, I've found that even on a LAN, my phone sometimes
                // needs a few seconds of buffer to avoid chopping.
                if (element.currentTime + 5 < end) {
                  element.currentTime = end - 0.5;
                }

                if (element.currentTime > start + 5) {
                  srcBuffer.remove(0, element.currentTime - 1);
                }

                let latency = end - element.currentTime;

                if (document.visibilityState == "visible") {
                  if (latency < lastLatency - 0.1 || latency > lastLatency + 0.1) {
                    infoElement.innerText = "Latency: " + (Math.round(latency * 10) / 10);
                    lastLatency = latency;
                  }
                }
              }

              await waitUpdate();

              srcBuffer.appendBuffer(bytes);
            }
          } catch (err) {
            console.error(err.stack);
          }

          await sleep(1000);
          console.log("trying again...");
        }
      }
    </script>
  </head>
  <body>
    <audio id="stream" controls preload="none"></audio>

    <p><button onclick="play(); event.currentTarget.style = 'display: none;'" style="width: 100%; height: 96px; font-size: 200%;">start</button></p>
  </body>
</html>
